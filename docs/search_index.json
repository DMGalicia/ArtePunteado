[["index.html", "Arte computacional punteado Capítulo 1 Introducción 1.1 Materiales requeridos", " Arte computacional punteado David Martínez-Galicia 2021-09-25 Capítulo 1 Introducción Este libro representa los esfuerzos realizados por mí, David Galicia, para entender cómo son generadas imágenes punteadas a través de computadoras. El objetivo de este proyecto recreativo es realizar un recorrido a tráves los algoritmos más conocidos para hacer arte punteado, observando desde resultados nada esperados hasta algunos que podríamos considerar arte. Todo el código necesario se encuentra explicado y puede ser utilizado para su diversión. El lenguaje de programación usado es R, pero esperaría que con la explicación brindada los algoritmos puedan ser implementados en el lenguaje de su preferencia. 1.1 Materiales requeridos Además del entorno de R, requeriremos algunas librerías para facilitar tareas en las que no nos enfocaremos mucho. library(dplyr) #Manipulación de datos library(imager) #Procesamiento de imágenes library(ggplot2) #Visualización de datos library(gridExtra) #Combinación gráficas en arreglos personalizados También necesitamos una imagen con la que probaremos nuestros algoritmos. Dado que sólo enfocaremos en hacer arte punteado con un color, las imagen con las que trabaremos deben de estar en escala de grises. La imagen que seleccioné muestra un helecho con fondo blanco. Aparentemente con esta imagen fueron probados muchos algoritmos que inicialmente se propusieron. Si desean ocupar otra imagen, la libreria imager permite manipular imágenes PNG, JPEG y BMP. im &lt;- load.image(&quot;http://dahtah.github.io/imager/images/stippling_leaves.png&quot;) im &lt;- grayscale(im) #Si es necesario, convertir la imagen a escala de grises #Gráfica con la imagen original p1 &lt;- im %&gt;% as.data.frame %&gt;% ggplot(aes(x, y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_fill_gradient(low=&quot;black&quot;, high=&quot;white&quot;) + # Color scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() # Formato p1 + ggtitle(&quot;Imagen de prueba&quot;) "],["algoritmos-que-distribuyen-el-error.html", "Capítulo 2 Algoritmos que distribuyen el error 2.1 Floyd-Steinberg 2.2 Jarvis-Judice-Ninke 2.3 Comparación de algoritmos", " Capítulo 2 Algoritmos que distribuyen el error Unos de los algoritmos más antiguos para hacer arte punteado son los que calculan el error de cada pixel y luego lo distribuyen a sus vecinos. Actualmente aunque existen varios algoritmos con distintas configuraciones para distribuir el ruido, todos se basan en la misma idea. 2.1 Floyd-Steinberg La primera versión de estos algoritmos fue propuesta por (Floyd and Steinberg 1976). Este algoritmo actualiza el valor de cada pixel y distribuye el error a 4 pixeles vecinos. El orden que toma para actualizar los pixeles es de izquierda a derecha y de arriba hacia abajo. Por cada pixel: Se calcula el valor actualizado usando la función round. Se calcula el error, restando el valor antiguo menos el valor nuevo. Se distribuye el error a pixeles vecinos. La siguiente tabla describe la distribución del error en los pixeles vecinos. Distribución del error en el Algoritmo Floyd-Steinberg Pixel actualizado + 7/16 del error + 3 /16 del error + 5/16 del error + 1/16 del error Es importante tomar en cuenta cuando el pixel a actualizar forma parte de límite de la imagen, algunos de los vecinos quedarán fuera de los límites de la imagen. Para solucionar este posible error, el algoritmo FSdithering encapsula la actualización de los vecinos en una sentencia try. #Algoritmo Floyd-Steinberg FSdithering &lt;- function(imagen){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular su nuevo valor imagen[x, y] &lt;- valorNuevo #Actualizar el valor antiguo error &lt;- valorViejo - valorNuevo # Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/16), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(3/16), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(5/16), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(1/16), silent = T) } } imagen %&gt;% as.cimg() } #Gráficación de los resultados p2 &lt;- FSdithering(im) %&gt;% as.data.frame() %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_fill_gradient(low=&quot;black&quot;, high=&quot;white&quot;) + # Color scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() # Formato #Comparación de los resultados grid.arrange(p1 + ggtitle(&quot;Imagen original&quot;), p2 + ggtitle(&quot;Algoritmo de Floyd-Steinberg&quot;), nrow = 1) 2.2 Jarvis-Judice-Ninke A diferencia de la formulación de Floyd y Steinberg, el algoritmo de (Jarvis, Judice, and Ninke 1976) incrementa a 12 el número de pixeles que emplea para distiribuir el ruido. Distribución del error en el algoritmo de Jarvis-Judice-Ninke Pixel actualizado + 7/48 del error + 5/48 del error + 3/48 del error + 5/48 del error + 7/48 del error + 5/48 del error + 3/48 del error + 1/48 del error + 3/48 del error + 5/48 del error + 3/48 del error + 1/48 del error #Algoritmo Jarvis-Judice-Ninke JJNdithering &lt;- function(imagen){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular el valor nuevo del pixel imagen[x, y] &lt;- valorNuevo error &lt;- valorViejo - valorNuevo # Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/48), silent = T) try(imagen[x+2, y ] &lt;- imagen[x+2, y ] + error*(5/48), silent = T) try(imagen[x-2, y+1] &lt;- imagen[x-2, y+1] + error*(3/48), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(5/48), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(7/48), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(5/48), silent = T) try(imagen[x+2, y+1] &lt;- imagen[x+2, y+1] + error*(3/48), silent = T) try(imagen[x-2, y+2] &lt;- imagen[x-2, y+2] + error*(1/48), silent = T) try(imagen[x-1, y+2] &lt;- imagen[x-1, y+2] + error*(3/48), silent = T) try(imagen[x , y+2] &lt;- imagen[x , y+2] + error*(5/48), silent = T) try(imagen[x+1, y+2] &lt;- imagen[x+1, y+2] + error*(3/48), silent = T) try(imagen[x+2, y+2] &lt;- imagen[x+2, y+2] + error*(1/48), silent = T) } } imagen %&gt;% as.cimg() } #Gráficación de resultados p3 &lt;- JJNdithering(im) %&gt;% as.data.frame() %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_fill_gradient(low=&quot;black&quot;, high=&quot;white&quot;) + # Color scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() # Formato #Comparación de resultados grid.arrange(p1 + ggtitle(&quot;Imagen original&quot;), p3 + ggtitle(&quot;Algoritmo de Jarvis-Judice-Ninke&quot;), nrow = 1) 2.3 Comparación de algoritmos En términos de desempeño, los algoritmos previos producen resultados muy similares. Sin emabrgo, el agoritmo de Jarvis y colegas tarda más en ejecutarse por el número de vecinos a actualizar y aparentemente en algunas secciones de fondo blanco genera pixeles negros. Por estas observaciones, yo sugeriría ocupar la versión de Floyd-Steinberg. grid.arrange(p2 + ggtitle(&quot;Algoritmo de Floyd-Steinberg&quot;), p3 + ggtitle(&quot;Algoritmo de Jarvis-Judice-Ninke&quot;), nrow = 1) Referencias "],["referencias.html", "Referencias", " Referencias "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
