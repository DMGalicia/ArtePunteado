[["index.html", "Arte computacional punteado Capítulo 1 Introducción 1.1 Materiales requeridos 1.2 Información del autor", " Arte computacional punteado David Martínez-Galicia - IIIA - UV 2021-10-03 Capítulo 1 Introducción Este libro representa los esfuerzos que he realizado para entender cómo es generado el arte punteado a través de computadoras. Mi objetivo principal es realizar un recorrido de los algoritmos más conocidos para poder entender su funcionamiento y generar mis propias obras de arte. En especial, me enfocaré en revisar los algoritmos que realizan arte punteado con un solo color. Todo el código necesario para generar las imágenes se encuentra explicado y puede ser utilizado para su diversión. El lenguaje de programación que uso es R, pero esperaría que con la explicación brindada los algoritmos puedan ser implementados en el lenguaje de su preferencia. 1.1 Materiales requeridos Además del entorno de R, requeriremos algunas librerías para facilitar tareas en las que no nos enfocaremos mucho. library(dplyr) #Manipulación de datos library(imager) #Procesamiento de imágenes library(ggplot2) #Visualización de datos library(gridExtra) #Combinación gráficas en arreglos personalizados library(gganimate) #Animación de gráficas También necesitaremos algunas imágenes para probar nuestros algoritmos. Dado que sólo enfocaremos en hacer arte punteado con un color, las imágenes que usaremos deben de estar en escala de grises. Particularmente, usare las siguientes imágenes: Helecho con fondo blanco: Esta imagen tiene 991 pixeles de ancho y 994 de alto. Ha sido ocupada por muchos trabajos para evaluar cómo los algoritmos generan los detalles, colores y matices. Perro pug: Esta imagen tiene un formato cuadrado de 55 pixeles y la generé reduciendo el tamaño de una foto propia. Será de particular ayuda para mostrar cómo los algoritmos transforman las imágenes originales. Si desean ocupar otras imágenes, la librería imager permite manipular imágenes PNG, JPEG y BMP. im1 &lt;- load.image(&quot;http://dmgalicia.github.io/ArtePunteado/images/stippling_leaves.png&quot;) im2 &lt;- load.image(&quot;http://dmgalicia.github.io/ArtePunteado/images/Pug.png&quot;) #Si es necesario, convertir la imagen a escala de grises con la función grayscale(im) #Gráfica con la imagen original p1 &lt;- im1 %&gt;% as.data.frame %&gt;% ggplot(aes(x, y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_fill_gradient(low=&quot;black&quot;, high=&quot;white&quot;) + # Color scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + # Formato ggtitle(label = &quot;Imagen de prueba 1&quot;, #Títulos subtitle = paste(width(im1), &quot;pixeles x&quot;, height(im1), &quot;pixeles.&quot;)) p2 &lt;- im2 %&gt;% as.data.frame %&gt;% ggplot(aes(x, y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_fill_gradient(low=&quot;black&quot;, high=&quot;white&quot;) + # Color scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + # Formato ggtitle(label = &quot;Imagen de prueba 2&quot;, #Títulos subtitle = paste(width(im2), &quot;pixeles x&quot;, height(im2), &quot;pixeles.&quot;)) grid.arrange(p1, p2, nrow = 1) 1.2 Información del autor ¡Hola! Mi nombre es David Martínez Galicia. Actualmente soy estudiante del Doctorado en Inteligencia Artificial de la Universidad Veracruzana y formo parte del grupo de divulgación Código IA. Mis principales temas de interés son la minería de datos y el aprendizaje máquina. De vez en cuando me hago proyectos aleatorios para divertirme un rato. Si tienen alguna duda, comentario o sugerencia, me pueden contactar a través de mi cuenta en Twitter o de mi correo personal. Espero disfruten jugar con estos algoritmos tanto como yo. "],["algoritmos-que-distribuyen-el-error.html", "Capítulo 2 Algoritmos que distribuyen el error 2.1 Floyd-Steinberg 2.2 Jarvis-Judice-Ninke", " Capítulo 2 Algoritmos que distribuyen el error Unos de los algoritmos más antiguos para hacer arte punteado son los que calculan el error de un pixel y luego lo distribuyen a sus vecinos. El orden que siguen para actualizar los pixeles generalmente es de izquierda a derecha y de arriba hacia abajo. Aunque existen varios algoritmos con distintas configuraciones para distribuir el ruido, todos se basan en la misma idea. 2.1 Floyd-Steinberg La primera versión de este tipo de algoritmos fue propuesta por (Floyd and Steinberg 1976). Esta implementación propone distribuir el error a 4 pixeles vecinos. Lo pasos que se deben de seguir por cada pixel son: Actualizar su valor usando la función \\(round\\). Calcular el error restando el valor antiguo menos el valor actualizado. Distribuir el error a pixeles vecinos. Los cuatro vecinos de un pixel \\(A\\) son: el pixel a su derecha \\((x_{A+1}, y_A)\\), su pixel inferior izquierdo \\((x_{A-1}, y_{A+1})\\), su pixel inferior \\((x_{A}, y_{A+1})\\) y su pixel inferior derecho \\((x_{A+1}, y_{A+1})\\). La tabla 1 muestra la proporción del error que se le suma a los vecinos de un pixel \\(A\\). Es importante tomar en cuenta que algunos de los vecinos podrían quedar fuera de posiciones válidas cuando el pixel a actualizar forma parte del límite de la imagen. Para solucionar este posible error, se puede encapsular la actualización de los vecinos en una sentencia \\(try\\). Tabla 1: Error que se le suma a los vecinos en el algoritmo Floyd-Steinberg. Coordenada del vecino Proporción del error \\((x_A+1, y_A)\\) \\(\\frac{7}{16} * error\\) \\((x_A-1, y_A+1)\\) \\(\\frac{3}{16} * error\\) \\((x_A, y_A+1)\\) \\(\\frac{5}{16} * error\\) \\((x_A+1, y_A+1)\\) \\(\\frac{1}{16} * error\\) El método \\(FSanimacion\\) genera una animación de los cambios que sufre una imagen con el algoritmo Floyd-Steinberg. Este método recibe dos entradas: la imagen a procesar y el número de pixeles que se actualizan consecutivamente. Sugiero que este método sea empleado en imágenes pequeñas ya que es muy costoso. Para el caso específico de la imagen de prueba 2, la animación se actualizará cada 110 pixeles. Esto corresponde a ver cómo se modifican tres filas de pixeles en cada transición: las primeras dos por actualización del color (blanco o negro) y la última por la distribución del error. #Animación Floyd-Steinberg FSanimacion &lt;- function(imagen, pixeles){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) contador &lt;- 0 #Define cada cuantos pixeles se actualiza la animación df &lt;- imagen %&gt;% as.cimg() %&gt;% as.data.frame() %&gt;% mutate(iteracion = 0) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular su nuevo valor imagen[x, y] &lt;- valorNuevo #Actualizar el valor antiguo error &lt;- valorViejo - valorNuevo #Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/16), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(3/16), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(5/16), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(1/16), silent = T) contador &lt;- contador + 1 #Cada X pixeles se guarda la imagen en un data frame if (contador %% pixeles == 0){ df2 &lt;- imagen %&gt;% as.cimg() %&gt;% as.data.frame() %&gt;% mutate(iteracion = contador) df &lt;- rbind(df,df2) } } } df } El tamaño de la imagen de prueba 2 no ayuda a darle el estilo de una imagen punteada, sin embargo, el resultado final se vería mejor si se adopta una gráfica de puntos. resultado &lt;- FSanimacion(im2, 110) #Animación p3 &lt;- resultado %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Animación de Floyd-Steinberg&quot;) + #Título transition_states(iteracion, transition_length = 1, state_length =1) + #Animación scale_fill_gradientn(colours = c(&quot;#000000&quot;, &quot;#ffffff&quot;), limits = c(0,1)) + # Color theme(title = element_text(size = 18)) p3 #Resultado final con puntos p4 &lt;- resultado %&gt;% filter(value == 0 &amp; iteracion == 2970) %&gt;% #Datos última iteración ggplot(aes(x,y)) + geom_point(size = 3) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Resultado final&quot;) + #Título theme(title = element_text(size = 18)) p4 El método \\(FSpunteado\\) realiza el mismo procedimiento que \\(FSanimacion\\), sin embargo, sólo regresa la imagen final. #Algortimo Floyd-Steinberg FSpunteado &lt;- function(imagen){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular su nuevo valor imagen[x, y] &lt;- valorNuevo #Actualizar el valor antiguo error &lt;- valorViejo - valorNuevo #Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/16), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(3/16), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(5/16), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(1/16), silent = T) } } imagen %&gt;% as.cimg() } A continuación, se muestra el resultado de procesar la imagen de prueba 1 con \\(FSpuntdo\\). Se puede observar que el tamaño de un pixel dentro de la cuadrícula de la imagen es muy pequeño debido a que las dimensiones de la imagen que son relativamente grandes. Las tonalidades alcanzadas y los detalles de la imagen procesada sugieren que el algoritmo se desempeña adecuadamente. Sin embargo, si se quisiera usar una gráfica de puntos no sería de utilidad dado que la densidad de los puntos sería muy alta y no permitiría observar los detalles. tiempo &lt;- proc.time() resultado &lt;- FSpunteado(im1) tiempo &lt;- proc.time() - tiempo p5 &lt;- resultado %&gt;% as.data.frame() %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Resultado del algoritmo Floyd-Steinberg&quot;, #Título subtitle = paste(&quot;Tiempo de ejecución:&quot;, sprintf(&quot;%.2f&quot;,tiempo[[3]]), &quot;segundos.&quot;)) + #Subtítulo scale_fill_gradientn(colours = c(&quot;#000000&quot;, &quot;#ffffff&quot;), limits = c(0,1)) # Color grid.arrange(p1, p5, nrow = 1) 2.2 Jarvis-Judice-Ninke A diferencia de la formulación de Floyd y Steinberg, el algoritmo de (Jarvis, Judice, and Ninke 1976) incrementa a 12 el número de pixeles que emplea para distribuir el ruido. La tabla 2 muestra la proporción del error que se le suma a los vecinos de un pixel \\(A\\). Tabla 2: Error que se le suma a los vecinos en el algoritmo Jarvis-Judice-Ninke Coordenada del vecino Proporción del error Coordenada del vecino Proporción del error \\((x_A+1, y_A)\\) \\(\\frac{7 }{48} * error\\) \\((x_A+2, y_A+1)\\) \\(\\frac{3}{48} * error\\) \\((x_A+2, y_A)\\) \\(\\frac{5}{48} * error\\) \\((x_A-2, y_A+2)\\) \\(\\frac{1}{48} * error\\) \\((x_A-2, y_A+1)\\) \\(\\frac{3}{48} * error\\) \\((x_A-1, y_A+2)\\) \\(\\frac{3}{48} * error\\) \\((x_A-1, y_A+1)\\) \\(\\frac{5}{48} * error\\) \\((x_A, y_A+2)\\) \\(\\frac{5}{48} * error\\) \\((x_A, y_A+1)\\) \\(\\frac{7}{48} * error\\) \\((x_A+1, y_A+2)\\) \\(\\frac{3}{48} * error\\) \\((x_A+1, y_A+1)\\) \\(\\frac{5}{48} * error\\) \\((x_A+2, y_A+2)\\) \\(\\frac{5}{48} * error\\) El método \\(JJNanimacion\\) genera la animación de los cambios que sufre una imagen con el algoritmo Jarvis-Judice-Ninke. Al igual que \\(FSanimacion\\), recibe una imagen y el número de pixeles que son actualizados consecutivamente. #Animación Jarvis-Judice-Ninke JJNanimacion &lt;- function(imagen, pixeles){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) contador &lt;- 0 #Define cada cuantos pixeles se actualiza la animación df &lt;- imagen %&gt;% as.cimg() %&gt;% as.data.frame() %&gt;% mutate(iteracion = 0) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular su nuevo valor imagen[x, y] &lt;- valorNuevo #Actualizar el valor antiguo error &lt;- valorViejo - valorNuevo #Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/48), silent = T) try(imagen[x+2, y ] &lt;- imagen[x+2, y ] + error*(5/48), silent = T) try(imagen[x-2, y+1] &lt;- imagen[x-2, y+1] + error*(3/48), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(5/48), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(7/48), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(5/48), silent = T) try(imagen[x+2, y+1] &lt;- imagen[x+2, y+1] + error*(3/48), silent = T) try(imagen[x-2, y+2] &lt;- imagen[x-2, y+2] + error*(1/48), silent = T) try(imagen[x-1, y+2] &lt;- imagen[x-1, y+2] + error*(3/48), silent = T) try(imagen[x , y+2] &lt;- imagen[x , y+2] + error*(5/48), silent = T) try(imagen[x+1, y+2] &lt;- imagen[x+1, y+2] + error*(3/48), silent = T) try(imagen[x+2, y+2] &lt;- imagen[x+2, y+2] + error*(1/48), silent = T) contador &lt;- contador + 1 #Cada X pixeles se guarda la imagen en un data frame if (contador %% pixeles == 0){ df2 &lt;- imagen %&gt;% as.cimg() %&gt;% as.data.frame() %&gt;% mutate(iteracion = contador) df &lt;- rbind(df,df2) } } } df } La diferencia principal que se puede observar en la animación es el número de pixeles afectados por la distribución del error. Mientras que en la animación del método \\(FSanimacion\\) existe una línea de pixeles modificados por el error, en la animación de \\(JJNanimacion\\) la línea se hace más gruesa debido a que el número de vecinos modificados aumenta. De igual forma, sugiero que este método se usado en imágenes pequeñas por su costo de procesamiento. resultado &lt;- JJNanimacion(im2, 110) #Animación p3 &lt;- resultado %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Animación de Floyd-Steinberg&quot;) + #Título transition_states(iteracion, transition_length = 1, state_length =1) + #Animación scale_fill_gradientn(colours = c(&quot;#000000&quot;, &quot;#ffffff&quot;), limits = c(0,1)) + # Color theme(title = element_text(size = 18)) p3 #Resultado final con puntos p4 &lt;- resultado %&gt;% filter(value == 0 &amp; iteracion == 2970) %&gt;% #Datos última iteración ggplot(aes(x,y)) + geom_point(size = 3) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Resultado final&quot;) + #Título theme(title = element_text(size = 18)) p4 Al igual que \\(FSpunteado\\), el método \\(JNNpunteado\\) realiza el procedimiento de distribución de ruido, pero sólo regresa la imagen final. Esta implementación está diseñada para ser ejecutada con imágenes de mayor tamaño en donde no nos interesa ver el cambio de cada pixel. #Algortimo Jarvis-Judice-Ninke JJNpunteado &lt;- function(imagen){ imagen &lt;- imagen %&gt;% as.matrix() #Conversión de la imagen a una matriz ancho &lt;- width(imagen) alto &lt;- height(imagen) for (y in seq(1, alto)) { for (x in seq(1, ancho)) { #Por cada pixel valorViejo &lt;- imagen[x, y] valorNuevo &lt;- round(imagen[x, y]) #Calcular su nuevo valor imagen[x, y] &lt;- valorNuevo #Actualizar el valor antiguo error &lt;- valorViejo - valorNuevo #Calcular el error #Difundir el error en los pixeles cercanos try(imagen[x+1, y ] &lt;- imagen[x+1, y ] + error*(7/48), silent = T) try(imagen[x+2, y ] &lt;- imagen[x+2, y ] + error*(5/48), silent = T) try(imagen[x-2, y+1] &lt;- imagen[x-2, y+1] + error*(3/48), silent = T) try(imagen[x-1, y+1] &lt;- imagen[x-1, y+1] + error*(5/48), silent = T) try(imagen[x , y+1] &lt;- imagen[x , y+1] + error*(7/48), silent = T) try(imagen[x+1, y+1] &lt;- imagen[x+1, y+1] + error*(5/48), silent = T) try(imagen[x+2, y+1] &lt;- imagen[x+2, y+1] + error*(3/48), silent = T) try(imagen[x-2, y+2] &lt;- imagen[x-2, y+2] + error*(1/48), silent = T) try(imagen[x-1, y+2] &lt;- imagen[x-1, y+2] + error*(3/48), silent = T) try(imagen[x , y+2] &lt;- imagen[x , y+2] + error*(5/48), silent = T) try(imagen[x+1, y+2] &lt;- imagen[x+1, y+2] + error*(3/48), silent = T) try(imagen[x+2, y+2] &lt;- imagen[x+2, y+2] + error*(1/48), silent = T) } } imagen %&gt;% as.cimg() } Las tonalidades y detalles alcanzados por \\(JNNpunteado\\) son muy buenos y se acercan al resultado del algoritmo de Floyd y Steinberg. Sin embargo, el cambio de color de algunos pixeles en el fondo blanco y su tiempo de ejecución lo convierten en una opción no ideal. Dependiendo nuestros intereses, podemos seleccionar qué algoritmos ejecutar y al final quedarnos con el resultado que nos parezca más atractivo. tiempo &lt;- proc.time() resultado &lt;- JJNpunteado(im1) tiempo &lt;- proc.time() - tiempo p6 &lt;- resultado %&gt;% as.data.frame() %&gt;% ggplot(aes(x,y)) + #Datos geom_raster(aes(fill = value), show.legend = FALSE) + #Gráfica scale_y_reverse() + xlab(&quot;&quot;) + ylab(&quot;&quot;) + theme_void() + #Formato ggtitle(label = &quot;Resultado del algoritmo Floyd-Steinberg&quot;, #Título subtitle = paste(&quot;Tiempo de ejecución:&quot;, sprintf(&quot;%.2f&quot;,tiempo[[3]]), &quot;segundos.&quot;)) + #Subtítulo scale_fill_gradientn(colours = c(&quot;#000000&quot;, &quot;#ffffff&quot;), limits = c(0,1)) # Color grid.arrange(p5, p6, nrow = 1) Referencias "],["referencias.html", "Referencias", " Referencias "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
